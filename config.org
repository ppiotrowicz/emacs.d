#+STARTUP: content
* General
** interface tweaks
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  (blink-cursor-mode -1)
  (global-visual-line-mode 1)
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-echo-area-message t)
  (setq inhibit-startup-message t)
  (setq ring-bell-function 'ignore)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq confirm-kill-emacs 'yes-or-no-p)
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier nil)
  (setq create-lockfiles nil)
  (setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC
** encoding
#+BEGIN_SRC emacs-lisp
  (setq coding-system-for-read 'utf-8)
  (setq coding-system-for-write 'utf-8)
  (setq sentence-end-double-space nil)
  (setq default-fill-column 80)
  (setq-default indent-tabs-mode nil)
#+END_SRC
** scratch
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message
        (format
         ";; %s\n\n"
         (replace-regexp-in-string
          "\n" "\n;; " ; comment each line
          (replace-regexp-in-string
           "\n$" ""    ; remove trailing linebreak
           (shell-command-to-string "fortune")))))
#+END_SRC
** better scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 9999)
  (setq scroll-preserve-screen-position t)
  (setq scroll-margin 3)
#+END_SRC
** backups
#+BEGIN_SRC emacs-lisp
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)
  (setq auto-save-default nil)
  (setq make-backup-files t)
  (setq backup-directory-alist `(("." . "~/.emacs.d/backups")))
  (setq vc-follow-symlinks t )
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
** hippie expand
#+BEGIN_SRC emacs-lisp
  (global-set-key [remap dabbrev-expand] 'hippie-expand)

  (setq hippie-expand-try-functions-list
        '(try-complete-file-name-partially
          try-complete-file-name
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol))
#+END_SRC
* Interface
** theme
#+BEGIN_SRC emacs-lisp
  ;; (use-package doom-themes
  ;;  :ensure t)

  (add-to-list 'load-path "~/.emacs.d/themes/emacs-doom-theme")
  (require 'doom-themes)
  (load-theme 'doom-one t)
  ;; brighter source buffers
  (add-hook 'find-file-hook 'doom-buffer-mode)
  ;; brighter minibuffer when active
  (add-hook 'minibuffer-setup-hook 'doom-buffer-mode)
#+END_SRC
** font
#+BEGIN_SRC emacs-lisp
  (set-default-font "Fira Mono for Powerline")
  (set-face-attribute 'default nil :height 120)
#+END_SRC
** diminish
#+BEGIN_SRC emacs-lisp
  (require 'diminish)
#+END_SRC
** parenthesis
#+BEGIN_SRC emacs-lisp
  (show-paren-mode)
  (setq show-paren-delay 0)
#+END_SRC
** whitespace
#+BEGIN_SRC emacs-lisp
  (require 'whitespace)
  (setq whitespace-line-column 80)
  (setq whitespace-style '(face tabs trailing))
  (global-whitespace-mode 1)
#+END_SRC
* Packages
** Interface
*** General
More convenient key definitions in emacs (https://github.com/noctuid/general.el)
#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t
    :demand general
    :config
    (progn
      (general-evil-setup)
      (setq general-default-keymaps 'evil-normal-state-map)))
#+END_SRC
*** Which key
Emacs package that displays available keybindings in popup (https://github.com/justbur/emacs-which-key)
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (progn
      (setq which-key-idle-delay 0.4)
      (which-key-setup-side-window-bottom)
      (which-key-mode)))
#+END_SRC
*** Bind-map
Bind personal keymaps in multiple locations https://github.com/justbur/emacs-bind-map
#+BEGIN_SRC emacs-lisp
  (use-package bind-map
    :ensure t
    :demand bind-map)
#+END_SRC
*** Powerline
#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :ensure t)
#+END_SRC
*** Ivy
Ivy - a generic completion frontend for Emacs, Swiper - isearch with an overview, and more. Oh, man! http://oremacs.com/swiper/
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :diminish ivy-mode
    :config
    (progn
      (use-package counsel
        :ensure t)

      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-height 15)
      (setq ivy-count-format "(%d/%d) ")

      (use-package swiper
        :ensure t
        :config
        :general (
           "C-s" 'swiper
           "C-c C-r" 'ivy-resume)
          )))
#+END_SRC
*** Avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :commands (avy-goto-char)
    :ensure t
    :config
    (avy-setup-default))
#+END_SRC
*** Evil
Extensible vi layer for emacs (https://bitbucket.org/lyro/evil/wiki/Home)
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config
    (progn
      (evil-mode 1)

      ;; https://bitbucket.org/lyro/evil/issues/444/evils-undo-granularity-is-too-coarse
      (setq evil-want-fine-undo 'fine)

      (use-package evil-surround
        :ensure t
        :config
        (progn
          (global-evil-surround-mode 1)))

      (use-package evil-nerd-commenter
        :commands (evilnc-comment-or-uncomment-lines)
        :ensure t)

      (define-key evil-normal-state-map (kbd "g c") 'evilnc-comment-or-uncomment-lines)

      (use-package evil-matchit
        :ensure t
        :commands evilmi-jump-items
        :init
        (progn
          (global-evil-matchit-mode 1)
          (define-key evil-normal-state-map "%" 'evilmi-jump-items)))

      ;; window movements
      (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
      (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
      (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
      (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)

      ;; ESC quits stuff
      (define-key evil-normal-state-map [escape] 'keyboard-quit)
      (define-key evil-visual-state-map [escape] 'keyboard-quit)
      (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
      ))
#+END_SRC
*** Folding
#+BEGIN_SRC emacs-lisp
  (use-package yafolding
    :ensure t
    :init
    (progn
      (define-key yafolding-mode-map (kbd "<C-S-return>") nil)
      (define-key yafolding-mode-map (kbd "<C-M-return>") nil)
      (define-key yafolding-mode-map (kbd "<C-return>") nil)
      (define-key evil-normal-state-map (kbd "zm") 'yafolding-toggle-all)
      (define-key evil-normal-state-map (kbd "zc") 'yafolding-hide-parent-element)
      (define-key evil-normal-state-map (kbd "za") 'yafolding-toggle-element)))
#+END_SRC
*** All the icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t
    :demand t)
#+END_SRC
*** Neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :config
    (progn
      (setq neo-show-updir-line nil
            neo-window-width 35
            neo-persist-show nil)
      (add-hook 'neotree-mode-hook (lambda () (setq-local line-spacing 5)))
      (add-hook 'neotree-mode-hook (lambda () (setq-local mode-line-format nil)))
      (add-hook 'neotree-mode-hook (lambda () (setq-local tab-width 1)))
      (defun neo-buffer--insert-fold-symbol (name &optional file-name)
        "Custom overriding function for the fold symbol.
  `NAME' decides what fold icon to use, while `FILE-NAME' decides
  what file icon to use."
        (or (and (equal name 'open)  (insert (all-the-icons-icon-for-dir file-name "down")))
            (and (equal name 'close) (insert (all-the-icons-icon-for-dir file-name "right")))
            (and (equal name 'leaf)  (insert (format "\t\t\t%s\t" (all-the-icons-icon-for-file file-name))))))

      (defun neo-buffer--insert-dir-entry (node depth expanded)
        (let ((node-short-name (neo-path--file-short-name node)))
          (insert-char ?\s (* (- depth 1) 2)) ; indent
          (when (memq 'char neo-vc-integration)
            (insert-char ?\s 2))
          (neo-buffer--insert-fold-symbol
           (if expanded 'open 'close) node)
          (insert-button (concat node-short-name "/")
                         'follow-link t
                         'face neo-dir-link-face
                         'neo-full-path node
                         'keymap neotree-dir-button-keymap)
          (neo-buffer--node-list-set nil node)
          (neo-buffer--newline-and-begin)))

      (defun neo-buffer--insert-file-entry (node depth)
        (let ((node-short-name (neo-path--file-short-name node))
              (vc (when neo-vc-integration (neo-vc-for-node node))))
          (insert-char ?\s (* (- depth 1) 2)) ; indent
          (when (memq 'char neo-vc-integration)
            (insert-char (car vc))
            (insert-char ?\s))
          (neo-buffer--insert-fold-symbol 'leaf node-short-name)
          (insert-button node-short-name
                         'follow-link t
                         'face (if (memq 'face neo-vc-integration)
                                   (cdr vc)
                                 neo-file-link-face)
                         'neo-full-path node
                         'keymap neotree-file-button-keymap)
          (neo-buffer--node-list-set nil node)
          (neo-buffer--newline-and-begin)))

      (defun neotree-projectile ()
        (interactive )
        (if (neo-global--window-exists-p)
            (neotree-hide)
          (neotree-find (or (ignore-errors (projectile-project-root))
                            (and (buffer-file-name) (file-name-nondirectory (buffer-file-name)))
                            (getenv "HOME")))))

      (defun neotree-projectile-find ()
        (interactive)
        (let ((cw (get-buffer-window (current-buffer))))
          (neotree-find)
          (select-window cw)))

      (add-hook 'neotree-mode-hook
                (lambda ()
                  (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)
                  (define-key evil-normal-state-local-map (kbd "g")   'neotree-refresh)
                  (define-key evil-normal-state-local-map (kbd "q")   'neotree-hide)
                  (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-stretch-toggle)
                  (define-key evil-normal-state-local-map (kbd "c")   'neotree-create-node)
                  (define-key evil-normal-state-local-map (kbd "d")   'neotree-delete-node)
                  (define-key evil-normal-state-local-map (kbd "r")   'neotree-rename-node)
                  ))
      ))
#+END_SRC
*** Company mode
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init
    (global-company-mode))
#+END_SRC
** Tools
*** Magit
It's Magit! A Git Porcelain inside Emacs. https://magit.vc
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit-status)
    :ensure t
    :config
    (use-package evil-magit
      :ensure t))
#+END_SRC
*** Magithub
#+BEGIN_SRC emacs-lisp
  (use-package magithub
    :ensure t
    :after magit)
#+END_SRC
*** Org
Org mode - your life in plain text (http://orgmode.org)
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :config
    (progn
      (setq org-export-coding-system 'utf-8)
      (setq org-indent-mode-turns-on-hiding-stars t)
      (setq org-adapt-indentation nil)
      (setq org-blank-before-new-entry '((heading . nil) (plain-list-item . auto)))
      (setq org-cycle-separator-lines 1)
      (setq org-cycle-include-plain-lists t)
      (setq org-entities-user '(("flat" "\\flat" nil "" "" "266D" "♭")
                                ("sharp" "\\sharp" nil "" "" "266F" "♯")))
      (setq org-fontify-done-headline t)
      (setq org-fontify-quote-and-verse-blocks t)
      (setq org-fontify-whole-heading-line t)
      (setq org-footnote-auto-label 'plain)
      (setq org-hide-emphasis-markers t)
      (setq org-hide-leading-stars t)
      (setq org-image-actual-width nil)
      (setq org-pretty-entities t)
      (setq org-pretty-entities-include-sub-superscripts t)
      (setq org-startup-folded t)
      (setq org-startup-indented t)
      (setq org-startup-with-inline-images nil)
      (setq org-use-sub-superscripts '{})
      (setq org-src-fontify-natively t)
      (setq org-startup-indented t)
      (setq org-hide-leading-stars t)
      (setq org-directory "~/org")
      (setq org-link-abbrev-alist
            '(("SD"   . "https://getbase.atlassian.net/browse/SD-")
              ("jira" . "https://getbase.atlassian.net/browse/")
              ("conf" . "https://getbase.atlassian.net/wiki/display/%h")))
      (setq org-agenda-files (list "~/org/home.org" "~/org/work.org"))
      (setq org-log-into-drawer "LOGBOOK")
      (setq org-clock-into-drawer "CLOCKING")
      (setq org-refile-targets '((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9)))
      (setq org-refile-use-outline-path t)
      (setq org-refile-allow-creating-parent-nodes (quote confirm))
      (setq org-tags-column -90)

      ;; Fontify checkboxes and dividers
      (defface org-list-bullet '((t ())) "Face for list bullets")
      (font-lock-add-keywords
       'org-mode '(("^ *\\([-+]\\|[0-9]+[).]\\) "
                    (1 'org-list-bullet))
                   ("^ *\\(-----+\\)$"
                    (1 'org-meta-line))))
      (setq org-capture-templates
            (quote
             (("w" "Work")
              ("wt" "Todo" entry
               (file+headline "~/org/work.org" "INBOX")
               "* TODO %?")
              ("h" "Home")
              ("ht" "Todo" entry
               (file+headline "~/org/home.org" "INBOX")
               "* TODO %?")
              ("o" "Org")
              ("ot" "Todo" entry
               (file+headline "~/org/todo.org" "INBOX")
               "* TODO %?")
              ("l" "TIL" entry
               (file+datetree "~/org/til.org")
               "* %? %^g")
              )))

      ;; fix level 1 heading colors
      (set-face-attribute 'org-level-1 nil
                          :background "#262c34"
                          :foreground "#00B3EF"
                          :box nil
                          :height 1.2)
    ))
#+END_SRC
*** Projectile
Project Interaction Library for Emacs (http://projectile.readthedocs.io)
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (progn
      (use-package counsel-projectile
        :ensure t)
      (setq projectile-switch-project-action 'counsel-projectile-find-file)))
#+END_SRC
*** Restclient
HTTP REST client tool for emacs (https://github.com/pashky/restclient.el)
#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :ensure t
    :mode (("\\.http\\'" . restclient-mode))
    :config
    (progn
      (defvar pp/restclient-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "s") 'restclient-http-send-current)
          (define-key map (kbd "c") 'restclient-copy-curl-command)
          map)
        "Restclient keymap.")

      (bind-map pp/restclient-map
        :evil-keys (",")
        :major-modes (restclient-mode))))
#+END_SRC
*** Github
#+BEGIN_SRC emacs-lisp
  (use-package github-browse-file
    :ensure t
    :defer t)
#+END_SRC
*** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t)
#+END_SRC
*** Dumb Jump
An Emacs "jump to definition" package
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :general (:keymaps 'evil-normal-state-map
                       "C-]" 'dumb-jump-go
                       "C-[" 'dump-jump-quick-look))
#+END_SRC
*** Paradox
#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :commands (paradox-list-packages)
    :ensure t
    :config
    (setq paradox-github-token t))
#+END_SRC
*** WGrep
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t)
#+END_SRC
*** Highlight symbol
#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :ensure t
    :init
    (progn
      (setq highlight-symbol-foreground-color "#fdf4c1")
      (setq highlight-symbol-colors '("#504945"))))
#+END_SRC
** Libraries
*** F
#+BEGIN_SRC emacs-lisp
  (use-package f
    :ensure t)
#+END_SRC
*** Dash
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)
#+END_SRC
*** Crux
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :ensure t
    :bind (("C-c o" . crux-open-with)))
#+END_SRC
** Languages
*** Ruby
#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :ensure t
    :config
    (progn
      (defvar pp/ruby-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "b i") 'bundle-install)
          (define-key map (kbd "b o") 'bundle-open)
          (define-key map (kbd "b e") 'bundle-exec)
          (define-key map (kbd "b c") 'bundle-console)
          (define-key map (kbd "b u") 'bundle-update)
          (define-key map (kbd "t a") 'rspec-verify-all)
          (define-key map (kbd "t b") 'rspec-verify)
          (define-key map (kbd "t l") 'rspec-run-last-failed)
          (define-key map (kbd "t r") 'rspec-rerun)
          (define-key map (kbd "t t") 'rspec-verify-single)
          (define-key map (kbd "t k") '(lambda () (interactive) (kill-buffer "*rspec-compilation*")))
          (define-key map (kbd "v c") 'rbenv-use-corresponding)
          (define-key map (kbd "v g") 'rbenv-use-global)
          map)
        "Ruby keymap.")
      (bind-map pp/ruby-map
        :evil-keys (",")
        :major-modes (ruby-mode))
      (use-package inf-ruby
        :ensure t)
      (use-package rbenv
        :ensure t
        :config
        (progn
          (global-rbenv-mode)
          (set-face-attribute 'rbenv-active-ruby-face nil
                              :inherit 'mode-line-face
                              :foreground "#eab700")
          (setq rspec-autosave-buffer t)
          (setq rspec-spec-command "rspec --format progress --no-profile")
          (add-hook 'projectile-after-switch-project-hook 'rbenv-use-corresponding)))
      (use-package rspec-mode
        :ensure t
        :config
        (progn
          (setq compilation-scroll-output t)
          (add-hook 'compilation-filter-hook 'inf-ruby-auto-enter)))
      (use-package bundler
        :ensure t)))
#+END_SRC
*** Coffescript
#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode
    :ensure t
    :config
    (progn
      (setq coffee-tab-width 2)
     ))
#+END_SRC
*** Markdown
Major mode for editing markdown files (http://jblevins.org/projects/markdown-mode/)
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC
*** Json
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t)
#+END_SRC
*** Csv
#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :ensure t)
#+END_SRC
* Modeline
** format
#+BEGIN_SRC emacs-lisp
  (defvar mode-line-height 30
    "How tall the mode-line should be. This is only respected in GUI emacs.")

  ;; Load powerline only when uncompiled, in order to generate the xpm bitmaps for
  ;; the mode-line. This is the tall blue bar on the left of the mode-line.
  ;; NOTE Compile this file for a faster startup!
  (eval-when-compile (require 'powerline))
  ;; FIXME Don't hardcode colors in
  (defvar mode-line-bar          (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#00B3EF" nil)))
  (defvar mode-line-eldoc-bar    (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#B3EF00" nil)))
  (defvar mode-line-inactive-bar (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 nil nil)))

  ;; Custom faces
  (defface mode-line-is-modified nil
    "Face for mode-line modified symbol")

  (defface mode-line-2 nil
    "The alternate color for mode-line text.")

  (defface mode-line-highlight nil
    "Face for bright segments of the mode-line.")

  (defface mode-line-count-face nil
    "Face for anzu/evil-substitute/evil-search number-of-matches display.")

  (defun pp/project-root (&optional strict-p)
    "Get the path to the root of your project."
    (let (projectile-require-project-root strict-p)
      (projectile-project-root)))

  ;; Initialization
  ;;

  ;; So the mode-line can keep track of "the current window"
  (defvar mode-line-selected-window nil)
  (defun pp/set-selected-window (&rest _)
    (let ((window (frame-selected-window)))
      (when (and (windowp window)
                 (not (minibuffer-window-active-p window)))
        (setq mode-line-selected-window window))))
  (add-hook 'window-configuration-change-hook #'pp/set-selected-window)
  (add-hook 'focus-in-hook #'pp/set-selected-window)
  (advice-add 'select-window :after 'pp/set-selected-window)
  (advice-add 'select-frame  :after 'pp/set-selected-window)

  ;;
  ;; Mode-line segments
  ;;

  (defun *buffer-path ()
    "Displays the buffer's full path relative to the project root (includes the
  project root). Excludes the file basename. See `*buffer-name' for that."
    (when buffer-file-name
      (propertize
       (f-dirname
        (let ((buffer-path (file-relative-name buffer-file-name (pp/project-root)))
              (max-length (truncate (/ (window-body-width) 1.75))))
          (concat (projectile-project-name) "/"
                  (if (> (length buffer-path) max-length)
                      (let ((path (reverse (split-string buffer-path "/" t)))
                            (output ""))
                        (when (and path (equal "" (car path)))
                          (setq path (cdr path)))
                        (while (and path (<= (length output) (- max-length 4)))
                          (setq output (concat (car path) "/" output))
                          (setq path (cdr path)))
                        (when path
                          (setq output (concat "../" output)))
                        (when (string-suffix-p "/" output)
                          (setq output (substring output 0 -1)))
                        output)
                    buffer-path))))
       'face (if active 'mode-line-2))))


  (defun *buffer-name ()
    "The buffer's base name or id."
    (s-trim-left (format-mode-line "%b")))

  (defun *buffer-pwd ()
    "Displays `default-directory', for special buffers like the scratch buffer."
    (propertize
     (concat "[" (abbreviate-file-name default-directory) "]")
     'face 'mode-line-2))

  (defun *buffer-state ()
    "Displays symbols representing the buffer's state
  (non-existent/modified/read-only)"
    (when buffer-file-name
       (concat (if (not (file-exists-p buffer-file-name))
                   (propertize (all-the-icons-faicon "ban" :height 1.3 :v-adjust 0.0) 'face 'mode-line-is-modified))
                 (if (buffer-modified-p)
                     (propertize (all-the-icons-faicon "circle" :height 1.3 :v-adjust 0.0) 'face 'mode-line-is-modified)
                     (propertize (all-the-icons-faicon "check-circle" :height 1.3 :v-adjust 0.0) 'face 'mode-line-is-saved))
               (if buffer-read-only
                   (propertize (all-the-icons-faicon "lock" :height 1.3 :v-adjust 0.0) 'face 'mode-line-is-modified)))))

  (defun *buffer-encoding-abbrev ()
    "The line ending convention used in the buffer."
    (if (memq buffer-file-coding-system '(utf-8 utf-8-unix))
        ""
      (symbol-name buffer-file-coding-system)))

  (defun *ruby-version ()
    "Currently active ruby version"
    (when (string-equal mode-name "Ruby")
      (concat " [" (rbenv--active-ruby-version) "]")))

  (defun *major-mode ()
    "The major mode, including process, environment and text-scale info."
    (concat (format-mode-line mode-name)
            (if (stringp mode-line-process) mode-line-process)
            (and (featurep 'face-remap)
                 (/= text-scale-mode-amount 0)
                 (format " (%+d)" text-scale-mode-amount))))

  (defun *major-mode-icon ()
      (propertize (format "%s " (all-the-icons-icon-for-buffer)
                  'help-echo (format "Major-mode: `%s`" major-mode)
                  'face `(:height 1.2 :family ,(all-the-icons-icon-family-for-buffer)))))

  (defun *git-vc ()
    (when vc-mode
      (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
        (concat
         (propertize (format " %s" (all-the-icons-alltheicon "git")) 'face `(:height 1.2) 'display '(raise -0.1))
         " · "
         (propertize (format "%s" (all-the-icons-octicon "git-branch"))
                     'face `(:height 1.3 :family ,(all-the-icons-octicon-family))
                     'display '(raise -0.1))
         (propertize (format " %s" branch) 'face `(:height 0.9))
         " · "))))

  (defun *selection-info ()
    "Information about the current selection, such as how many characters and
  lines are selected, or the NxM dimensions of a block selection."
    (when (and active (evil-visual-state-p))
      (propertize
       (let ((reg-beg (region-beginning))
             (reg-end (region-end))
             (evil (eq 'visual evil-state)))
         (let ((lines (count-lines reg-beg (min (1+ reg-end) (point-max))))
               (chars (- (1+ reg-end) reg-beg))
               (cols (1+ (abs (- (evil-column reg-end)
                                 (evil-column reg-beg))))))
           (cond
            ;; rectangle selection
            ((or (bound-and-true-p rectangle-mark-mode)
                 (and evil (eq 'block evil-visual-selection)))
             (format " %dx%dB " lines (if evil cols (1- cols))))
            ;; line selection
            ((or (> lines 1) (eq 'line evil-visual-selection))
             (if (and (eq evil-state 'visual) (eq evil-this-type 'line))
                 (format " %dL " lines)
               (format " %dC %dL " chars lines)))
            (t (format " %dC " (if evil chars (1- chars)))))))
       'face 'mode-line-highlight)))

  (defun *macro-recording ()
    "Display current macro being recorded."
    (when (and active defining-kbd-macro)
      (propertize
       (format " %s ▶ " (char-to-string evil-this-macro))
       'face 'mode-line-highlight)))

  (defun *evil-substitute ()
    "Show number of :s matches in real time."
    (when (and (evil-ex-p) (evil-ex-hl-active-p 'evil-ex-substitute))
      (propertize
       (let ((range (if evil-ex-range
                        (cons (car evil-ex-range) (cadr evil-ex-range))
                      (cons (line-beginning-position) (line-end-position))))
             (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
         (if pattern
             (format " %s matches "
                     (count-matches pattern (car range) (cdr range))
                     evil-ex-argument)
           " ... "))
       'face (if active 'mode-line-count-face))))

  (defun *buffer-position ()
    "A more vim-like buffer position."
    (let ((start (window-start))
          (end (window-end))
          (pend (point-max)))
      (format "%d%%%%" (/ end 0.01 pend))))

  (defun *time ()
    (let* ((hour (string-to-number (format-time-string "%I")))
           (icon (all-the-icons-wicon (format "time-%s" hour) :height 1.3 :v-adjust 0.0)))
      (concat
       (propertize (format-time-string "%H:%M ") 'face `(:height 0.9))
       (propertize (format "%s " icon) 'face `(:height 1.0 :family ,(all-the-icons-wicon-family)) 'display '(raise -0.0)))))

  (defun *dot-separator ()
      (propertize " · " 'face `(:height 0.9)))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq powerline-default-separator 'slant)
  (defun pp/mode-line (&optional id)
    `(:eval
      (let* ((active (eq (selected-window) mode-line-selected-window))
             (lhs (list (propertize " " 'display (if active mode-line-bar mode-line-inactive-bar))
                        (*macro-recording)
                        (*selection-info)
                        " "
                        (*buffer-path)
                        (*buffer-name)
                        " "
                        (*buffer-state)
                        ,(if (eq id 'scratch) '(*buffer-pwd))))
             (rhs (list (*buffer-encoding-abbrev)
                        (*git-vc)
                        ;; (*vc)
                        (*major-mode-icon)
                        (*major-mode)
                        (*ruby-version)
                        (*dot-separator)
                        (propertize
                         (concat "(%l,%c)" (*dot-separator) (*buffer-position))
                         'face (if active 'mode-line-2))
                        (*dot-separator)
                        (*time)))
             (middle (propertize
                      " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                                         ,(1+ (string-width (format-mode-line rhs)))))))))
        (list lhs middle rhs))))

  (setq-default mode-line-format (pp/mode-line))
#+END_SRC
* Hydras
** zoom
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-zoom ()
    "zoom"
    ("+" text-scale-increase "in")
    ("-" text-scale-decrease "out")
    ("0" (text-scale-adjust 0) "reset")
    ("q" nil "quit" :color blue))
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-org (:color red :columns 3)
    "Org Mode Movements"
    ("n" outline-next-visible-heading "next heading")
    ("p" outline-previous-visible-heading "prev heading")
    ("N" org-forward-heading-same-level "next heading at same level")
    ("P" org-backward-heading-same-level "prev heading at same level")
    ("u" outline-up-heading "up heading")
    ("g" org-goto "goto" :exit t))
#+END_SRC
** search
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-search (:post highlight-symbol-remove-all)
    "Search"
    ("n" highlight-symbol-next "next")
    ("p" highlight-symbol-prev "prev")
    ("/" find-symbol-at-point "in project")
    ("s" pp/swiper-at-point "swiper")
    ("q" highlight-symbol-remove-all "quit" :exit t))
#+END_SRC
* Global key bindings
** global
#+BEGIN_SRC emacs-lisp
  (bind-map pp/global-map
    :evil-keys ("SPC"))
#+END_SRC
** buffers
#+BEGIN_SRC emacs-lisp
  (let ((map pp/global-map))
    (define-key map (kbd "b b") 'ivy-switch-buffer)
    (define-key map (kbd "b d") 'kill-this-buffer)
    (define-key map (kbd "b n") 'evil-buffer-new)
    (define-key map (kbd "TAB") 'switch-to-previous-buffer)
    map)
#+END_SRC
** help
#+BEGIN_SRC emacs-lisp
  (let ((map pp/global-map))
    (define-key map (kbd "h c") 'edit-emacs-config)
    (define-key map (kbd "h v") 'counsel-describe-variable)
    (define-key map (kbd "h f") 'counsel-describe-function)
    (define-key map (kbd "h p") 'paradox-list-packages)
    map)
#+END_SRC
** files
#+BEGIN_SRC emacs-lisp
  (let ((map pp/global-map))
    (define-key map (kbd "f f") 'counsel-find-file)
    (define-key map (kbd "f r") 'rename-file)
    map)
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (let ((map pp/global-map))
    (define-key map (kbd "g b") 'magit-blame)
    (define-key map (kbd "g s") 'magit-status)
    (define-key map (kbd "g o") 'github-browse-file)
    map)
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp
  (let ((map pp/global-map))
    (define-key map (kbd "p p") 'counsel-projectile-switch-project)
    (define-key map (kbd "p f") 'counsel-projectile-find-file)
    (define-key map (kbd "p /") 'find-in-project)
    (define-key map (kbd "/") 'find-in-project)
    (define-key map (kbd "p k") 'projectile-kill-buffers)
    map)
#+END_SRC
** windows
#+BEGIN_SRC emacs-lisp
  (let ((map pp/global-map))
    (define-key map (kbd "w s") 'split-window-vertically)
    (define-key map (kbd "w S") 'split-window-below-and-focus)
    (define-key map (kbd "w v") 'split-window-horizontally)
    (define-key map (kbd "w V") 'split-window-right-and-focus)
    (define-key map (kbd "w c") 'delete-window)
    (define-key map (kbd "w =") 'balance-windows)
    (define-key map (kbd "w w") 'other-window)
    (define-key map (kbd "w f") 'toggle-fullscreen)
    map)
#+END_SRC
** open files
#+BEGIN_SRC emacs-lisp
  (let ((map pp/global-map))
    (define-key map (kbd "o c") 'org-capture)
    (define-key map (kbd "o h") '(lambda () (interactive) (find-file "~/org/home.org")))
    (define-key map (kbd "o t") '(lambda () (interactive) (find-file "~/org/today.org")))
    (define-key map (kbd "o w") '(lambda () (interactive) (find-file "~/org/work.org")))
    (define-key map (kbd "o l") '(lambda () (interactive) (find-file "~/org/til.org")))
    map)
#+END_SRC
** misc
#+BEGIN_SRC emacs-lisp
  (define-key pp/global-map (kbd "SPC") 'avy-goto-char)
  (define-key pp/global-map (kbd ":") 'execute-extended-command)
  (define-key pp/global-map (kbd "'") 'iterm-focus)
  (define-key pp/global-map (kbd "t") 'neotree-projectile)
  (general-nmap "*" 'pp/highlight-symbol-hydra)
#+END_SRC
* Functions
#+BEGIN_SRC emacs-lisp
  (defun pp/highlight-symbol-hydra ()
    "Highlights symbol and begins a search hydra."
    (interactive)
    (highlight-symbol)
    (hydra-search/body))

  (defun edit-emacs-config ()
    "Open emacs config file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defun find-in-project ()
    "Searches in current project."
    (interactive)
    (counsel-ag nil (projectile-project-root)))

  (defun find-symbol-at-point ()
    "Searches for symbol under cursor in current project."
    (interactive)
    (counsel-ag (thing-at-point 'symbol) (projectile-project-root)))

  (defun switch-to-previous-buffer ()
    "Switch to previously open buffer.
  Repeated invocations toggle between the two most recently open buffers."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (defun toggle-fullscreen ()
    "Toggle full screen."
    (interactive)
    (set-frame-parameter
       nil 'fullscreen
       (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

  (defun split-window-right-and-focus ()
    "Split the window horizontally and focus the new window."
    (interactive)
    (split-window-right)
    (windmove-right))

  (defun split-window-below-and-focus ()
    "Split the window vertically and focus the new window."
    (interactive)
    (split-window-below)
    (windmove-down))

  (defun pp/swiper-at-point ()
    (interactive)
    (swiper (thing-at-point 'symbol)))

  (defun iterm-focus ()
    (interactive)
    (do-applescript
     " do shell script \"open -a iTerm\"\n"
     ))
#+END_SRC
* Other
#+BEGIN_SRC emacs-lisp
  (diminish 'undo-tree-mode)
  (diminish 'auto-revert-mode)

  (setq gc-cons-threshold 800000)
#+END_SRC
* Todo
- bindings for prev/next changes (hydra?)
- swiper enhancements https://github.com/abo-abo/swiper/wiki/Sort-files-by-mtime
- .net/omnisharp
- SPC keymaps in dired mode
- SPC keymaps in magit mode
- dired-x
- ESC doesn't work in terminal
- comint mode for shell and irb
- https://github.com/alf/ob-restclient.el
- org conf shortcut - replace spaces with +
- https://github.com/pidu/git-timemachine
- https://m.reddit.com/r/emacs/comments/51jvai/making_modern_emacs_themes/?utm_source=mweb_redirect&utm_medium=twitter&compact=true
- https://github.com/hlissner/.emacs.d/blob/master/core/core-os-osx.el#L65
